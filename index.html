<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Python Dependency Visualizer (Robust Parser)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    body { margin: 0; background: #0d1117; color: #c9d1d9; font-family: monospace; display: flex; height: 100vh; overflow: hidden; }
    #sidebar { width: 350px; background: #161b22; border-right: 1px solid #30363d; display: flex; flex-direction: column; }
    #sidebar-header { padding: 16px; border-bottom: 1px solid #30363d; background: #010409; }
    #log { flex: 1; overflow-y: auto; padding: 10px; font-size: 12px; }
    #content { flex: 1; overflow: auto; padding: 20px; }
    .log-entry { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #21262d; }
    .log-import { color: #79c0ff; font-weight: bold; display: block; margin-bottom: 2px; }
    .log-checking { color: #8b949e; display: block; margin-left: 12px; }
    .log-found { color: #3fb950; display: block; margin-left: 12px; font-weight: bold; }
    .log-lib { color: #d2a8ff; display: block; margin-left: 12px; font-style: italic; }
  </style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-header">
    <h3>Dependency Resolver</h3>
    <small id="lbl-status" style="color:#8b949e">Initializing...</small>
  </div>
  <div id="log"></div>
</div>

<div id="content">
  <pre><code id="code" class="language-python"></code></pre>
</div>

<script>
/* ===============================
   1. CONFIG & PROXY
================================ */
const params = new URLSearchParams(location.search);
const REPO   = params.get("repo");
const COMMIT = params.get("commit");
const PATH   = params.get("path");

const CORS_PROXY = "https://corsproxy.io/?";
const RAW_BASE = "https://raw.githubusercontent.com";
const fileCache = new Map();

function log(html) {
  const div = document.createElement("div");
  div.className = "log-entry";
  div.innerHTML = html;
  document.getElementById("log").appendChild(div);
}

async function fetchRaw(filePath) {
  const targetUrl = `${RAW_BASE}/${REPO}/${COMMIT}/${filePath}`;
  const proxyUrl = CORS_PROXY + encodeURIComponent(targetUrl);

  if (fileCache.has(targetUrl)) return fileCache.get(targetUrl);

  try {
    const res = await fetch(proxyUrl);
    if (res.status === 200) {
      const text = await res.text();
      fileCache.set(targetUrl, text);
      return text;
    }
  } catch (e) { console.error(e); }
  return null;
}

/* ===============================
   2. ROBUST PARSER (Stateful)
================================ */

function parseImports(code) {
  const results = [];
  
  // Step 1: Normalize code (remove comments, join multi-lines)
  // We want to turn:
  //    from x import (
  //        y,
  //        z
  //    )
  // Into: "from x import y, z"
  
  const lines = code.split("\n");
  let buffer = "";
  let inParens = false;
  
  const logicalLines = [];

  for (let line of lines) {
    // Strip comments
    line = line.split("#")[0].trim();
    if (!line) continue;

    buffer += " " + line;
    
    // Check parenthesis balance in the buffer
    const openCount = (buffer.match(/\(/g) || []).length;
    const closeCount = (buffer.match(/\)/g) || []).length;

    if (openCount === closeCount) {
      // Logical line complete
      if (buffer.trim()) logicalLines.push(buffer.trim());
      buffer = "";
    }
  }

  // Step 2: Parse Logical Lines
  for (let line of logicalLines) {
    // A. "from ... import ..."
    // Regex: ^from ([\.\w]+) import (.*)
    let match = line.match(/^from\s+([\.\w]+)\s+import\s+(.*)/);
    
    if (match) {
      const source = match[1];
      let targetsStr = match[2];
      
      // Clean up parentheses
      targetsStr = targetsStr.replace(/[()]/g, ""); 
      
      // Split by comma: "x, y as z"
      const targets = targetsStr.split(",").map(t => t.trim());
      
      // Determine level (dots)
      let level = 0;
      let module = source;
      const dots = source.match(/^(\.+)/);
      if (dots) {
        level = dots[1].length;
        module = source.substring(level); 
        if (!module) module = null; // e.g. "from . import x" -> module=null
      }

      targets.forEach(t => {
        // Remove aliases "x as y" -> "x"
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName) {
           results.push({ module, name: cleanName, level });
        }
      });
      continue;
    }

    // B. "import ..."
    // Regex: ^import (.*)
    match = line.match(/^import\s+(.*)/);
    if (match) {
      const targetsStr = match[1];
      // Handle "import os, sys.path as sp"
      const targets = targetsStr.split(",").map(t => t.trim());
      
      targets.forEach(t => {
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName) {
          results.push({ module: cleanName, name: null, level: 0 });
        }
      });
    }
  }
  
  return results;
}

/* ===============================
   3. RESOLUTION LOGIC
================================ */

function getDirname(p) {
  if (!p.includes("/")) return ""; 
  return p.substring(0, p.lastIndexOf("/"));
}

function joinPath(...parts) {
  return parts.filter(p => p).join("/").replace(/\/+/g, "/");
}

function generateCandidates(imp, currentFile) {
  const candidates = [];
  
  // Base Dir
  let baseDir = "";
  if (imp.level > 0) {
    baseDir = getDirname(currentFile);
    for (let i = 1; i < imp.level; i++) baseDir = getDirname(baseDir);
  }

  const modParts = imp.module ? imp.module.split(".") : [];

  // Priority 1: Check imported ITEM as a file
  // Case: from pkg import Mod -> pkg/Mod.py
  if (imp.name && imp.name !== "*") {
    const fullParts = [...modParts, imp.name];
    const path = joinPath(baseDir, ...fullParts);
    candidates.push(`${path}.py`);
    candidates.push(`${path}/__init__.py`);
  }

  // Priority 2: Check MODULE as a file
  // Case: import pkg.Mod -> pkg/Mod.py
  // Case: from pkg.Mod import x -> pkg/Mod.py (x is variable)
  if (modParts.length > 0) {
    const path = joinPath(baseDir, ...modParts);
    candidates.push(`${path}.py`);
    candidates.push(`${path}/__init__.py`);
  }
  
  // Priority 3: Parent Package (for variables in init)
  // Case: from pkg import x -> pkg/__init__.py (x is variable)
  // Note: We only check this if module exists
  if (imp.module && imp.name) {
      // This is covered by Priority 2 implicitly if module is a folder
      // But if module is "pkg", Priority 2 checks "pkg.py" and "pkg/__init__.py"
      // So we are covered.
  }

  return candidates;
}

/* ===============================
   4. MAIN
================================ */

async function main() {
  const statusEl = document.getElementById("lbl-status");
  
  if (!REPO || !COMMIT || !PATH) {
    statusEl.innerText = "Error: Missing params";
    document.body.innerHTML += "<h2 style='padding:20px'>Missing URL Params</h2>";
    return;
  }

  statusEl.innerText = "Fetching source...";
  const code = await fetchRaw(PATH);
  
  if (!code) {
    statusEl.innerText = "Error: 404";
    document.getElementById("code").innerText = "Could not find file.";
    return;
  }

  // Display Code
  document.getElementById("code").textContent = code;
  hljs.highlightElement(document.getElementById("code"));

  statusEl.innerText = "Analyzing imports...";
  const imports = parseImports(code);
  
  // Run Check
  const checked = new Set();

  for (const imp of imports) {
    // UI Label
    let label = "";
    if (imp.level === 0 && !imp.name) label = `import ${imp.module}`;
    else {
      const dots = ".".repeat(imp.level);
      const mod = imp.module || "";
      const nm = imp.name || "";
      label = `from ${dots}${mod} import ${nm}`;
    }

    if (checked.has(label)) continue;
    checked.add(label);

    const candidates = generateCandidates(imp, PATH);
    let html = `<span class="log-import">${label}</span>`;
    let found = false;

    for (const cand of candidates) {
      html += `<span class="log-checking">${cand}</span>`;
      
      // Check cache or fetch
      let exists = false;
      if (fileCache.has(`${RAW_BASE}/${REPO}/${COMMIT}/${cand}`)) exists = true;
      else {
         const txt = await fetchRaw(cand);
         if (txt) exists = true;
      }

      if (exists) {
        html += `<span class="log-found">✔ FOUND</span>`;
        found = true;
        break;
      }
    }

    if (!found) html += `<span class="log-lib">➡ Library / Built-in</span>`;
    log(html);
  }
  
  statusEl.innerText = "Done.";
}

main();

</script>
</body>
</html>
