<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Python Dependency Visualizer (Multi-Root Heuristic)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    /* Styling remains the same as the previous correct version */
    body { margin: 0; background: #0d1117; color: #c9d1d9; font-family: monospace; display: flex; height: 100vh; overflow: hidden; }
    #sidebar { width: 350px; background: #161b22; border-right: 1px solid #30363d; display: flex; flex-direction: column; }
    #sidebar-header { padding: 16px; border-bottom: 1px solid #30363d; background: #010409; }
    #log { flex: 1; overflow-y: auto; padding: 10px; font-size: 12px; }
    #content { flex: 1; overflow: auto; padding: 20px; }
    .log-entry { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #21262d; }
    .log-import { color: #79c0ff; font-weight: bold; display: block; margin-bottom: 2px; }
    .log-checking { color: #8b949e; display: block; margin-left: 12px; }
    .log-found { color: #3fb950; display: block; margin-left: 12px; font-weight: bold; }
    .log-lib { color: #d2a8ff; display: block; margin-left: 12px; font-style: italic; }
  </style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-header">
    <h3>Dependency Resolver</h3>
    <small id="lbl-status" style="color:#8b949e">Initializing...</small>
  </div>
  <div id="log"></div>
</div>

<div id="content">
  <pre><code id="code" class="language-python"></code></pre>
</div>

<script>
/* ===============================
   1. CONFIG & PROXY
================================ */
const params = new URLSearchParams(location.search);
const REPO   = params.get("repo");
const COMMIT = params.get("commit");
const PATH   = params.get("path");

const CORS_PROXY = "https://corsproxy.io/?";
const RAW_BASE = "https://raw.githubusercontent.com";
const fileCache = new Map();

function log(html) {
  const div = document.createElement("div");
  div.className = "log-entry";
  div.innerHTML = html;
  document.getElementById("log").appendChild(div);
}

async function fetchRaw(filePath) {
  const targetUrl = `${RAW_BASE}/${REPO}/${COMMIT}/${filePath}`;
  const proxyUrl = CORS_PROXY + encodeURIComponent(targetUrl);

  if (fileCache.has(targetUrl)) return fileCache.get(targetUrl);

  try {
    const res = await fetch(proxyUrl);
    if (res.status === 200) {
      const text = await res.text();
      fileCache.set(targetUrl, text);
      return text;
    }
  } catch (e) { console.error(e); }
  return null;
}

/* ===============================
   2. ROBUST PARSER (Stateful)
================================ */

function parseImports(code) {
  const results = [];
  const lines = code.split("\n");
  let buffer = "";
  const logicalLines = [];

  for (let line of lines) {
    line = line.split("#")[0].trim(); // Strip comments
    if (!line) continue;

    buffer += " " + line;
    
    // Check parenthesis balance
    const openCount = (buffer.match(/\(/g) || []).length;
    const closeCount = (buffer.match(/\)/g) || []).length;

    if (openCount === closeCount) {
      if (buffer.trim()) logicalLines.push(buffer.trim());
      buffer = "";
    }
  }

  for (let line of logicalLines) {
    let match = line.match(/^from\s+([\.\w]+)\s+import\s+(.*)/);
    
    if (match) { // A. "from ... import ..."
      const source = match[1];
      let targetsStr = match[2].replace(/[()]/g, ""); 
      const targets = targetsStr.split(",").map(t => t.trim());
      
      let level = 0;
      let module = source;
      const dots = source.match(/^(\.+)/);
      if (dots) {
        level = dots[1].length;
        module = source.substring(level); 
        if (!module) module = null;
      }

      targets.forEach(t => {
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName && cleanName !== '*') { // Ignore pure wildcards for resolution
           results.push({ module, name: cleanName, level });
        }
      });
      continue;
    }

    match = line.match(/^import\s+(.*)/);
    if (match) { // B. "import ..."
      const targetsStr = match[1];
      const targets = targetsStr.split(",").map(t => t.trim());
      
      targets.forEach(t => {
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName) {
          results.push({ module: cleanName, name: null, level: 0 });
        }
      });
    }
  }
  
  return results;
}

/* ===============================
   3. PATH RESOLUTION LOGIC (WITH MULTI-ROOT HEURISTIC)
================================ */

function getDirname(p) {
  if (!p.includes("/")) return ""; 
  return p.substring(0, p.lastIndexOf("/"));
}

function joinPath(...parts) {
  return parts.filter(p => p).join("/").replace(/\/+/g, "/");
}

/**
 * Generates all potential base directories for an absolute import
 * from the repo root up to the current file's directory.
 * @param {string} currentFile - e.g. 'backend/services/user.py'
 * @returns {string[]} - e.g. ['', 'backend', 'backend/services']
 */
function getPossibleRoots(currentFile) {
    const dir = getDirname(currentFile);
    const parts = dir.split('/').filter(p => p); // ['backend', 'services']
    const roots = [""]; // Start with the actual repo root

    for (let i = 0; i < parts.length; i++) {
        const subpath = parts.slice(0, i + 1).join('/');
        roots.push(subpath);
    }
    // Reverse for priority: start deep, then move shallower
    return roots.reverse(); 
}

function generateCandidates(imp, currentFile) {
    const candidates = [];
    const modParts = imp.module ? imp.module.split(".") : [];
    
    // Determine the set of base directories to check
    let baseDirs = [];
    if (imp.level > 0) {
        // RELATIVE IMPORT: Only one base directory
        let baseDir = getDirname(currentFile);
        for (let i = 1; i < imp.level; i++) {
            baseDir = getDirname(baseDir);
        }
        baseDirs.push(baseDir);
    } else {
        // ABSOLUTE IMPORT: Check all directories up to current file
        baseDirs = getPossibleRoots(currentFile);
    }

    // Iterate through all possible roots/bases
    for (const baseDir of baseDirs) {
        // Priority 1: Check imported ITEM as a file (e.g., from pkg import Mod)
        if (imp.name && imp.name !== "*") {
            const fullParts = [...modParts, imp.name];
            const path = joinPath(baseDir, ...fullParts);
            candidates.push(`${path}.py`);
            candidates.push(`${path}/__init__.py`);
        }

        // Priority 2: Check MODULE as a file (e.g., import pkg.Mod)
        if (modParts.length > 0) {
            const path = joinPath(baseDir, ...modParts);
            candidates.push(`${path}.py`);
            candidates.push(`${path}/__init__.py`);
        }
    }
    
    return candidates;
}

/* ===============================
   4. MAIN EXECUTION
================================ */

async function main() {
  const statusEl = document.getElementById("lbl-status");
  
  if (!REPO || !COMMIT || !PATH) {
    statusEl.innerText = "Error: Missing params";
    document.body.innerHTML += "<h2 style='padding:20px'>Missing URL Params</h2>";
    return;
  }

  statusEl.innerText = "Fetching source...";
  const code = await fetchRaw(PATH);
  
  if (!code) {
    statusEl.innerText = "Error: 404";
    document.getElementById("code").innerText = `Could not find file at ${PATH}.`;
    return;
  }

  // Display Code
  document.getElementById("code").textContent = code;
  hljs.highlightElement(document.getElementById("code"));

  statusEl.innerText = "Analyzing imports...";
  const imports = parseImports(code);
  
  const checked = new Set();

  for (const imp of imports) {
    // UI Label
    let label = "";
    const dots = ".".repeat(imp.level);
    const mod = imp.module || "";
    const nm = imp.name || "";
    
    if (imp.level === 0 && !imp.name) label = `import ${mod}`;
    else label = `from ${dots}${mod} import ${nm}`;

    const uniqueKey = `${imp.level}|${imp.module}|${imp.name}`;
    if (checked.has(uniqueKey)) continue;
    checked.add(uniqueKey);

    const candidates = generateCandidates(imp, PATH);
    let html = `<span class="log-import">${label}</span>`;
    let found = false;

    // Search and Fetch Candidates
    for (const cand of candidates) {
      html += `<span class="log-checking">${cand}</span>`;
      
      let exists = false;
      if (fileCache.has(`${RAW_BASE}/${REPO}/${COMMIT}/${cand}`)) exists = true;
      else {
         const txt = await fetchRaw(cand);
         if (txt) exists = true;
      }

      if (exists) {
        html += `<span class="log-found">✔ FOUND</span>`;
        found = true;
        break;
      }
    }

    if (!found) html += `<span class="log-lib">➡ Library / Built-in</span>`;
    log(html);
  }
  
  statusEl.innerText = "Done.";
}

main();

</script>
</body>
</html>
