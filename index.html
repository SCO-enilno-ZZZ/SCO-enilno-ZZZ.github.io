<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Python Dependency Scraper + Usage Finder</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <style>
    /* --- Layout & Base --- */
    body { margin: 0; background: #0d1117; color: #c9d1d9; font-family: monospace; display: flex; height: 100vh; overflow: hidden; }
    #sidebar { width: 380px; background: #161b22; border-right: 1px solid #30363d; display: flex; flex-direction: column; }
    #sidebar-header { padding: 16px; border-bottom: 1px solid #30363d; background: #010409; }
    #log { flex: 1; overflow-y: auto; padding: 10px; font-size: 12px; }
    #content { flex: 1; overflow: auto; padding: 20px; position: relative; }
    
    /* --- Log Styling --- */
    .log-entry { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid #21262d; }
    .log-import { color: #79c0ff; font-weight: bold; display: block; margin-bottom: 2px; }
    .log-checking { color: #8b949e; display: block; margin-left: 12px; }
    .log-found { color: #3fb950; display: block; margin-left: 12px; font-weight: bold; }
    .log-cached { color: #e3b341; display: block; margin-left: 12px; font-weight: bold; }
    .log-lib { color: #d2a8ff; display: block; margin-left: 12px; font-style: italic; }

    /* --- Usage Popup Styling --- */
    #usage-popup {
      display: none;
      position: absolute;
      background: #161b22;
      border: 1px solid #30363d;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      border-radius: 6px;
      max-width: 600px;
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
      padding: 10px;
      font-size: 12px;
    }
    .usage-header {
      font-weight: bold;
      color: #f0f6fc;
      border-bottom: 1px solid #30363d;
      padding-bottom: 6px;
      margin-bottom: 6px;
      display: flex;
      justify-content: space-between;
    }
    .usage-close { cursor: pointer; color: #ff7b72; }
    .usage-file {
      margin-top: 8px;
      color: #79c0ff;
      font-weight: bold;
      background: #0d1117;
      padding: 4px;
      border-radius: 4px;
    }
    .usage-line {
      display: block;
      padding: 2px 8px;
      color: #8b949e;
      border-left: 2px solid #30363d;
      margin-left: 4px;
      white-space: pre-wrap;
      cursor: pointer;
    }
    .usage-line:hover { background: #21262d; color: #c9d1d9; }
    .usage-line-num { color: #6e7681; margin-right: 8px; user-select: none; }
    .usage-match { color: #e3b341; font-weight: bold; }
  </style>
</head>
<body>

<div id="sidebar">
  <div id="sidebar-header">
    <h3>Dependency Resolver</h3>
    <small id="lbl-status" style="color:#8b949e">Initializing...</small>
  </div>
  <div id="log"></div>
</div>

<div id="content">
  <pre><code id="code" class="language-python"></code></pre>
  
  <div id="usage-popup"></div>
</div>

<script>
/* ===============================
   1. GLOBAL CONFIG
================================ */
const params = new URLSearchParams(location.search);
const REPO   = params.get("repo");
const COMMIT = params.get("commit");
const PATH   = params.get("path");

const CORS_PROXY = "https://corsproxy.io/?";
const RAW_BASE = "https://raw.githubusercontent.com";

// --- THE CACHE ---
window.projectFiles = new Map();

// --- KEYWORDS TO IGNORE ---
const IGNORED_KEYWORDS = new Set([
  "import", "from", "as", "def", "class", "return", "pass", "if", "elif", "else", 
  "for", "while", "try", "except", "finally", "with", "lambda", "yield", "None", 
  "True", "False", "and", "or", "not", "is", "in", "continue", "break", "raise",
  "global", "nonlocal", "assert", "del", "async", "await", "print",
  "=", "!=", "==", "+", "-", "*", "/", "%", "<", ">", "<=", ">=", "(", ")", "[", "]", "{", "}", ":", ",", "."
]);

function log(html) {
  const div = document.createElement("div");
  div.className = "log-entry";
  div.innerHTML = html;
  const logEl = document.getElementById("log");
  logEl.appendChild(div);
  logEl.scrollTop = logEl.scrollHeight;
}

/* ===============================
   2. NETWORK & CACHE
================================ */

async function fetchAndCache(filePath) {
  if (window.projectFiles.has(filePath)) {
    return { content: window.projectFiles.get(filePath), cached: true };
  }
  const targetUrl = `${RAW_BASE}/${REPO}/${COMMIT}/${filePath}`;
  const proxyUrl = CORS_PROXY + encodeURIComponent(targetUrl);
  try {
    const res = await fetch(proxyUrl);
    if (res.status === 200) {
      const text = await res.text();
      window.projectFiles.set(filePath, text);
      return { content: text, cached: false };
    }
  } catch (e) { console.error(e); }
  return { content: null, cached: false };
}

/* ===============================
   3. PARSING LOGIC
================================ */

function parseImports(code) {
  const results = [];
  const lines = code.split("\n");
  let buffer = "";
  const logicalLines = [];

  for (let line of lines) {
    line = line.split("#")[0].trim(); 
    if (!line) continue;
    buffer += " " + line;
    const openCount = (buffer.match(/\(/g) || []).length;
    const closeCount = (buffer.match(/\)/g) || []).length;
    if (openCount === closeCount) {
      if (buffer.trim()) logicalLines.push(buffer.trim());
      buffer = "";
    }
  }

  for (let line of logicalLines) {
    let match = line.match(/^from\s+([\.\w]+)\s+import\s+(.*)/);
    if (match) { 
      const source = match[1];
      let targetsStr = match[2].replace(/[()]/g, ""); 
      const targets = targetsStr.split(",").map(t => t.trim());
      
      let level = 0;
      let module = source;
      const dots = source.match(/^(\.+)/);
      if (dots) {
        level = dots[1].length;
        module = source.substring(level); 
        if (!module) module = null;
      }
      targets.forEach(t => {
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName && cleanName !== '*') { 
           results.push({ module, name: cleanName, level });
        }
      });
      continue;
    }
    match = line.match(/^import\s+(.*)/);
    if (match) { 
      const targetsStr = match[1];
      const targets = targetsStr.split(",").map(t => t.trim());
      targets.forEach(t => {
        const cleanName = t.split(/\s+as\s+/)[0].trim();
        if (cleanName) {
          results.push({ module: cleanName, name: null, level: 0 });
        }
      });
    }
  }
  return results;
}

/* ===============================
   4. PATH RESOLUTION
================================ */

function getDirname(p) {
  if (!p.includes("/")) return ""; 
  return p.substring(0, p.lastIndexOf("/"));
}
function joinPath(...parts) {
  return parts.filter(p => p).join("/").replace(/\/+/g, "/");
}
function getPossibleRoots(currentFile) {
    const dir = getDirname(currentFile);
    const parts = dir.split('/').filter(p => p); 
    const roots = [""]; 
    for (let i = 0; i < parts.length; i++) {
        const subpath = parts.slice(0, i + 1).join('/');
        roots.push(subpath);
    }
    return roots.reverse(); 
}
function generateCandidates(imp, currentFile) {
    const candidates = [];
    const modParts = imp.module ? imp.module.split(".") : [];
    let baseDirs = [];
    if (imp.level > 0) {
        let baseDir = getDirname(currentFile);
        for (let i = 1; i < imp.level; i++) baseDir = getDirname(baseDir);
        baseDirs.push(baseDir);
    } else {
        baseDirs = getPossibleRoots(currentFile);
    }
    for (const baseDir of baseDirs) {
        if (imp.name && imp.name !== "*") {
            const fullParts = [...modParts, imp.name];
            const path = joinPath(baseDir, ...fullParts);
            candidates.push(`${path}.py`);
            candidates.push(`${path}/__init__.py`);
        }
        if (modParts.length > 0) {
            const path = joinPath(baseDir, ...modParts);
            candidates.push(`${path}.py`);
            candidates.push(`${path}/__init__.py`);
        }
    }
    return candidates;
}

/* ===============================
   5. USAGE SEARCH (CTRL + CLICK)
================================ */

function getWordAtClick(e) {
  // Robustly extract the word under cursor using Range API
  // This handles spaces, dots, parens, etc. as delimiters
  if (document.caretRangeFromPoint) { // Standard
    const range = document.caretRangeFromPoint(e.clientX, e.clientY);
    if (!range) return null;
    return expandRangeToWord(range);
  } else if (document.caretPositionFromPoint) { // Firefox
    const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
    if (!pos) return null;
    const range = document.createRange();
    range.setStart(pos.offsetNode, pos.offset);
    range.collapse(true);
    return expandRangeToWord(range);
  }
  return null;
}

function expandRangeToWord(range) {
  const node = range.startContainer;
  const offset = range.startOffset;
  
  if (node.nodeType !== Node.TEXT_NODE) return null;
  const text = node.textContent;
  
  // Define separators (non-word characters)
  const isSeparator = (char) => /[^a-zA-Z0-9_]/.test(char);

  let start = offset;
  let end = offset;

  // Move left
  while (start > 0 && !isSeparator(text[start - 1])) {
    start--;
  }
  // Move right
  while (end < text.length && !isSeparator(text[end])) {
    end++;
  }

  const word = text.substring(start, end).trim();
  return word;
}

function showUsages(word, x, y) {
  const popup = document.getElementById("usage-popup");
  if (!word || IGNORED_KEYWORDS.has(word) || !isNaN(word)) {
    popup.style.display = "none";
    return;
  }

  // Search logic
  let resultsHtml = `<div class="usage-header">
                       <span>Usages of "${word}"</span>
                       <span class="usage-close" onclick="document.getElementById('usage-popup').style.display='none'">✕</span>
                     </div>`;
  
  let totalFound = 0;

  // Iterate over all cached files
  for (const [path, content] of window.projectFiles.entries()) {
    const lines = content.split("\n");
    const matches = [];

    lines.forEach((line, index) => {
      // Regex for Whole Word Match
      const regex = new RegExp(`\\b${word}\\b`);
      if (regex.test(line)) {
        // Highlight the word in the preview line
        const highlighted = line.replace(/</g, "&lt;").replace(/>/g, "&gt;")
                                .replace(regex, `<span class="usage-match">${word}</span>`);
        matches.push({ num: index + 1, html: highlighted });
      }
    });

    if (matches.length > 0) {
      totalFound += matches.length;
      resultsHtml += `<div class="usage-file">${path}</div>`;
      matches.forEach(m => {
        resultsHtml += `<div class="usage-line">
                          <span class="usage-line-num">${m.num}</span>
                          ${m.html}
                        </div>`;
      });
    }
  }

  if (totalFound === 0) {
    resultsHtml += `<div style="padding:10px; color:#8b949e">No other usages found in cached files.</div>`;
  }

  // Position and Show
  popup.innerHTML = resultsHtml;
  popup.style.display = "block";
  popup.style.left = Math.min(x, window.innerWidth - 620) + "px"; // Prevent overflow right
  popup.style.top = Math.min(y, window.innerHeight - 420) + "px"; // Prevent overflow bottom
}

// Bind Global Click Listener
document.getElementById("code").addEventListener("click", (e) => {
  // Only trigger on CTRL + Click
  if (!e.ctrlKey && !e.metaKey) return; 

  e.preventDefault();
  const word = getWordAtClick(e);
  
  if (word) {
    console.log("Searching for:", word);
    showUsages(word, e.pageX, e.pageY);
  }
});

// Close popup on click outside
document.addEventListener("click", (e) => {
  const popup = document.getElementById("usage-popup");
  if (popup.style.display === "block" && !popup.contains(e.target) && !e.ctrlKey) {
    popup.style.display = "none";
  }
});

/* ===============================
   6. MAIN EXECUTION
================================ */

async function main() {
  const statusEl = document.getElementById("lbl-status");
  
  if (!REPO || !COMMIT || !PATH) {
    statusEl.innerText = "Error: Missing params";
    document.body.innerHTML += "<h2>Missing URL Params</h2>";
    return;
  }

  statusEl.innerText = "Fetching source...";
  const mainResult = await fetchAndCache(PATH);
  
  if (!mainResult.content) {
    statusEl.innerText = "Error: 404";
    document.getElementById("code").innerText = `Could not find file at ${PATH}.`;
    return;
  }

  document.getElementById("code").textContent = mainResult.content;
  hljs.highlightElement(document.getElementById("code"));

  statusEl.innerText = "Analyzing imports...";
  const imports = parseImports(mainResult.content);
  
  const checkedImports = new Set();

  for (const imp of imports) {
    const dots = ".".repeat(imp.level);
    const mod = imp.module || "";
    const nm = imp.name || "";
    const label = (imp.level === 0 && !imp.name) ? `import ${mod}` : `from ${dots}${mod} import ${nm}`;

    const uniqueKey = `${imp.level}|${imp.module}|${imp.name}`;
    if (checkedImports.has(uniqueKey)) continue;
    checkedImports.add(uniqueKey);

    const candidates = generateCandidates(imp, PATH);
    let html = `<span class="log-import">${label}</span>`;
    let found = false;

    for (const cand of candidates) {
      const result = await fetchAndCache(cand);
      if (result.content) {
        if (result.cached) {
            html += `<span class="log-cached">✔ CACHED: ${cand}</span>`;
        } else {
            html += `<span class="log-checking">${cand}</span>`;
            html += `<span class="log-found">✔ FOUND</span>`;
        }
        found = true;
        break; 
      } else {
        html += `<span class="log-checking">${cand}</span>`;
      }
    }

    if (!found) html += `<span class="log-lib">➡ Library / Built-in</span>`;
    log(html);
  }
  
  const count = window.projectFiles.size;
  statusEl.innerText = `Done. Cached ${count} files. (Ctrl+Click symbols to find usages)`;
}

main();

</script>
</body>
</html>
